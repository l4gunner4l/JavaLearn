Большинство операций в Java аналогичны тем, которые применяются в других си-подобных языках. Есть унарные операции (выполняются над одним операндом), бинарные - над двумя операндами, а также тернарные - выполняются над тремя операндами. Операндом является переменная или значение (например, число), участвующее в операции. Рассмотрим все виды операций.<br/>
<br/>
В арифметических операциях участвуют числами. В Java есть бинарные арифметические операции (производятся над двумя операндами) и унарные (выполняются над одним операндом). К бинарным операциям относят следующие:<br/>
<br/>
<b>+ операция сложения двух чисел:</b><br/>
<br/>
<tt>int a = 10;<br/>
int b = 7;<br/>
int c = a + b;  // 17<br/>
int d = 4 + b;  // 11</tt><br/>
<br/>
<b>- операция вычитания двух чисел:</b><br/>
<br/>
<tt>int a = 10;<br/>
int b = 7;<br/>
int c = a - b;  // 3<br/>
int d = 4 - a;  // -6</tt><br/>
<br/>
<b>* операция умножения двух чисел</b><br/>
<br/>
<tt>int a = 10;<br/>
int b = 7;<br/>
int c = a * b;  // 70<br/>
int d = b * 5;  // 35</tt><br/>
<br/>
<b>/ операция деления двух чисел:</b><br/>
<br/>
<tt>int a = 20;<br/>
int b = 5;<br/>
int c = a / b;  // 4<br/>
double d = 22.5 / 4.5;  // 5.0</tt><br/>
<br/>
При делении стоит учитывать, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа, даже если результат присваивается переменной float или double:<br/>
<br/>
<tt>double k = 10 / 4;     // 2<br/>
System.out.println(k);</tt><br/>
<br/>
Чтобы результат представлял числос плавающей точкой, один из операндов также должен представлять число с плавающей точкой:<br/>
<br/>
<tt>double k = 10.0 / 4;     // 2.5<br/>
System.out.println(k);</tt><br/>
<br/>
<b>% получение остатка от деления двух чисел:</b><br/>
<br/>
<tt>int a = 33;<br/>
int b = 5;<br/>
int c = a % b;  // 3<br/>
int d = 22 % 4; // 2 (22 - 4*5 = 2)</tt><br/>
<br/>
Также есть две унарные арифметические операции, которые производятся над одним числом: ++ (инкремент) и -- (декремент). Каждая из операций имеет две разновидности: префиксная и постфиксная:<br/>
<br/>
<b>++ (префиксный инкремент)</b><br/>
<br/>
Предполагает увеличение переменной на единицу, например, z=++y (вначале значение переменной y увеличивается на 1, а затем ее значение присваивается переменной z)<br/>
<br/>
<tt>int a = 8;<br/>
int b = ++a;<br/>
System.out.println(a);  // 9<br/>
System.out.println(b);  // 9</tt><br/>
<br/>
<b>++ (постфиксный инкремент)</b><br/>
<br/>
Также представляет увеличение переменной на единицу, например, z=y++ (вначале значение переменной y присваивается переменной z, а потом значение переменной y увеличивается на 1)<br/>
<br/>
<tt>int a = 8;<br/>
int b = a++;<br/>
System.out.println(a);  // 9<br/>
System.out.println(b);  // 8</tt><br/>
<br/>
<b>-- (префиксный декремент)</b><br/>
<br/>
уменьшение переменной на единицу, например, z=--y (вначале значение переменной y уменьшается на 1, а потом ее значение присваивается переменной z)<br/>
<br/>
<tt>int a = 8;<br/>
int b = --a;<br/>
System.out.println(a);  // 7<br/>
System.out.println(b);  // 7</tt><br/>
<br/>
<b>-- (постфиксный декремент)</b><br/>
<br/>
z=y-- (сначала значение переменной y присваивается переменной z, а затем значение переменной y уменьшается на 1)<br/>
<br/>
<tt>int a = 8;<br/>
int b = a--;<br/>
System.out.println(a);  // 7<br/>
System.out.println(b);  // 8</tt><br/>
<br/>
<br/>
<b>Приоритет арифметических операций</b><br/>
<br/>
Одни операции имеют больший приоритет чем другие и поэтому выполняются вначале. Операции в порядке уменьшения приоритета:<br/>
<br/>
(), []<br/>
затем ++ (инкремент), -- (декремент)<br/>
потом * (умножение), / (деление), % (остаток от деления)<br/>
и в конце + (сложение), - (вычитание)<br/>
<br/>

Приоритет операций следует учитывать при выполнении набора арифметических выражений:<br/>
<tt>int a = 8;<br/>
int b = 7;<br/>
int c = a + 5 * ++b;<br/>
System.out.println(c);  // 48</tt><br/>
<br/>
Вначале будет выполняться операция инкремента ++b, которая имеет больший приоритет - она увеличит значение переменной b и возвратит его в качестве результата. Затем выполняется умножение 5 * ++b, и только в последнюю очередь выполняется сложение a + 5 * ++b<br/>
<br/>

Скобки позволяют переопределить порядок вычислений:<br/>
<tt>int a = 8;<br/>
int b = 7;<br/>
int c = (a + 5) * ++b;<br/>
System.out.println(c);  // 104</tt><br/>
<br/>
Несмотря на то, что операция сложения имеет меньший приоритет, но вначале будет выполняться именно сложение, а не умножение, так как операция сложения заключена в скобки.<br/>
<br/>
<br/>

<b>Ассоциативность операций</b><br/>
<br/>
Кроме приоритета операции отличаются таким понятием как ассоциативность. Когда операции имеют один и тот же приоритет, порядок вычисления определяется ассоциативностью операторов. В зависимости от ассоциативности есть два типа операторов:<br/>
<br/>
Левоассоциативные операторы, которые выполняются слева направо<br/>
<br/>
Правоассоциативные операторы, которые выполняются справа налево<br/>
<br/>
Так, некоторые операции, например, операции умножения и деления, имеют один и тот же приоритет. Какой же тогда будет результат в выражении:<br/>
<br/>
<tt>int x = 10 / 5 * 2;</tt><br/>
<br/>
Стоит нам трактовать это выражение как (10 / 5) * 2 или как 10 / (5 * 2)? Ведь в зависимости от трактовки мы получим разные результаты.<br/>
<br/>
Поскольку все арифметические операторы (кроме префиксного инкремента и декремента) являются левоассоциативными, то есть выполняются слева направо. Поэтому выражение 10 / 5 * 2 необходимо трактовать как (10 / 5) * 2, то есть результатом будет 4.<br/>
<br/><br/>
<b>Операции с числами с плавающей точкой</b><br/>
<br/>
Следует отметить, что числа с плавающей точкой не подходят для финансовых и других вычислений, где ошибки при округлении могут быть критичными. Например:<br/>
<br/>
<tt>double d = 2.0 - 1.1;<br/>
System.out.println(d);</tt><br/>
<br/>
В данном случае переменная d будет равна не 0.9, как можно было бы изначально предположить, а 0.8999999999999999. Подобные ошибки точности возникают из-за того, что на низком уровне для представления чисел с плавающей точкой применяется двоичная система, однако для числа 0.1 не существует двоичного представления, также как и для других дробных значений. Поэтому если в таких случаях обычно применяется класс BigDecimal, который позволяет обойти подобные ситуации.<br/>